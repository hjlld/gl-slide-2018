{
    "slide-1": "<p>大家好，我叫郝稼力，山东青岛人。大概在 2010 年我接触到了 WebGL，于是和小伙伴一起做引擎、翻译教程、搭设区，一通折腾。</p><ul><li class=\"ml-3\">Oak3D 引擎：2011年发布，国内第一个基于现代流程化引擎思想编写的 WebGL 3D 引擎。当年用的人还是挺多的（说“用”其实过分了，大家都是在玩儿，说好听叫测试），记得 Black Berry 的一个哥们是我们的忠实使用者，总是给我们提 issue 和 feature request。现在已经停止更新。</li><li class=\"ml-3\">HiWebGL 社区：翻译了 http://LearningWebGL.com 的那套基于 nehe 的 OpenGL 教程改编的 WebGL 教程。每日没黑没夜的去 Twitter、Khronos 邮件组、http://LearningWebGL.com 翻译新闻，经常每天晚上三瓶啤酒几篇新闻的生活。中间因为资金原因，服务器没有更新，下线了一段时间。现在已经恢复上线，数据恢复至 2012 年 6 月，已经停止更新。</li></ul><p>今天与大家分享一下 WebGL 的历史和现状。</p>",
    "slide-2": "<p>在 8 年前，WebGL 刚刚诞生的时候，那时候的网页开发还处于 JQuery 风生水起的时代 —— 学好 JQuery 走遍天下都不怕。这使得对 JQuery 已经谙熟于心的前端程序员们得以有时间和精力去学习更多的前端知识，尤其是被认为是未来的 HTML5，其中包括了 CSS3、ES6/7、更多 HTML5 标签和特性等，其中就包括 WebGL。WebGL 是万维网诞生以来第一个可以精确控制网页上每一个像素的技术（如果你愿意的话），但是 WebGL 是一个相当低等级的接口，比如说算加法，1+1+1=3，这是 WebGL 的算法；而高等级的 API 的算法则是 1 x 3 = 3。在 WebGL 之前，几乎所有的网页技术都是高等级的 API， 他们简单易行，就像是一个科学计算器；而 WebGL 则是一个只有 + 号的计算机，如果想算减法，对不起，请加一个负数。所以许多前端程序员对 WebGL 画一个三角形需要好几十行代码感到惊诧，这是他们以前未曾遇到过的，但是他们有时间有精力去学习这项新的技术。</p>",
    "slide-3": "<p>而现在则是一个开局一个 npm，开发全靠 install 的时代，对于一个刚刚入行的前端程序员来说，他在掌握基本的切图、CSS、HTML知识外，还要去学习新的 JS 语法，Webpack 的使用，React、Angular、Vue 的双向数据绑定、虚拟 DOM 和其他的知识，而高阶的前端程序员已经在研究如何通过阅读 Chromium 和 V8 的 C++ 代码来优化网页性能了。在这个前端知识爆炸的时代，前端程序员能做好本职工作跟上节奏已经很不容易了，很少有人会学习 WebGL 了。</p>",
    "slide-4": "所以， GAME OVER。",
    "slide-5": "但是在这末日来临时，总有一批英雄站了出来。他们义无反顾的投入 WebGL 的深坑，下面我们来讲一下他们的故事。",
    "slide-6": "不同于其他人，当时很多人认为没有必要深入学习图形学和 GL 知识，只要掌握上层图形库的用法即可，在那时候 Three.js 已经初具雏形，程序员不必知道所以然，就可以用几行代码绘制出漂亮的 3D 图形。但是这些英雄们则不同。下面我将讲述一下他们遇到的奇遇和最后的境地，来一窥 WebGL 在这几年中的发展。",
    "slide-7": "首先是像素，这是一个所有前端程序员都非常熟悉的概念。一开始像素很简单，后来有了 rem、vh，方便了很多，后来有了 Retina，像素变得麻烦了。",
    "slide-8": "但是像素是人发明出来的，在像素之前，还有另外一些显示技术，例如矢量显示器。也许有工科生见过早年的示波器，上面的显示屏使用的就是矢量显示技术。矢量显示器是 CRT 显示器的一种，当然很多年轻人可能连 CRT 显示器都没有用过，他们一出生就是 LCD 的时代。矢量显示中没有像素的概念，而是根据矢量划线。矢量是一个纯数学概念，大家可以对照前端图形中的矢量图形的概念来进行比对，矢量本身可以用很少的字节数描述很多的图形信息，但是他们只适用于颜色数较少、图形比较简单的情况，例如 SVG。但是对于复杂图形来说，他们就捉襟见肘了，例如请使用 SVG 绘制一张 AKB48 的全家福照片。所以人们发明了光栅化的像素显示技术。",
    "slide-9": "<h3>按 PageDown 和 PageUp 切换 3D 视图</h3><p>这就是像素。在像素上绘制看起来是一件很简单的事情，我们前端每天都让显示器绘制无数的图形，但是我们可能用一秒钟的生命来考虑显示器是如何绘制的？比如直线。如果绘制一条水平或者垂直的直线，那应该是一件轻松的事情；但是斜线呢，从(6, 6)点到(19, 9)点的这条绿色的斜线是如何绘制出来的，为什么一行四个像素而另一行三个像素，为什么不是五个像素或者两个像素？是的，自从图形学诞生以来，先后出现了很多的直线绘制算法，目前大家看到的这个直线绘制算法叫做“布雷森汉姆直线算法”，是由布雷森汉姆于 1062 年在 IBM 实验室发明的，它是直线算法中最简洁（可以用一个 for 循环完成）、性能最好（只用到整数和加减法）的算法。复杂的图形显示可能要绘制无数的直线，而每次绘制都要调用直线算法，计算机科学家们一直在寻找简单而性能更优的算法，当然，在这之前有很多其他算法，它们或者用到了浮点数，或者需要乘除之类的“复杂运算”，对于我们平时来说，尤其是 JS 中只有 Number 没有 Int，可能已经习惯了，但是对于图形程序员来说，这都是不必要的性能消耗。</p><p>注释：后面我会继续讲这些东西，就先不写了，太多了</p>",
    "slide-10": "<p>如果说上面这些已经足够让人畏惧的话，那么 Shader 则是真正的恐惧魔王。在 LearningWebGL 的教程中，第一节课就接触到了 Shader，作者无比自豪的指出：“要知道，在 OpenGL 中，至少到中级才会接触到 Shader。”，但是在 WebGL 中，这是一个第一节课就必须知道的东西。这个超级玛丽第一关的演示，并不是一段视频，而是用 1426 行 GLSL 代码绘制出来的。</p>",
    "slide-11": "<p>这个超级玛丽第一关的演示，并不是一段视频，而是用 1426 行 GLSL 代码绘制出来的。</p>",
    "slide-12": "<p>顶点着色器，TODO</p>",
    "slide-13": "<p>片元着色器，TODO</p>",
    "slide-14": "<p>我们现在在座的各位前端，都是 ADOBE 公司 CSS Shader 的幸存者，因为 ADOBE 在 FLASH 末期疯狂拥抱 HTML5， 他们提出了这个疯狂的想法，就是让我们各位用上述的 GLSL 语言来写 CSS！幸好这玩意死掉了，否则我们的脱发速度会更快。</p>",
    "slide-15": "<p>这张图片是 CSS Shader 效果的遗迹。</p>",    
    "slide-16": "<p>讲一讲 WebGL 现在的状态</p>",    
    "slide-17": "<p>WebGL 很有可能被 WebGPU 或 WebDX 取代，WebGL 2.0 很可能是 WebGL 的最后一个版本，不会再有 3.0 了。且行且珍惜……</p><p>后面会放很多炫酷的 DEMO，会介绍基本上是前端最容易起步使用 WebGL 的方式：基于vue和标记语言的 vue-babylonjs。会对比 Three.js 和 Babylon.js。也可以做待选话题。</p>"
}